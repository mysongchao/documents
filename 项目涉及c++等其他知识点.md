### http路由

> #####路由作用就是这样，将URL转换为类路径。



### 消息队列

> “消息队列”是在消息的传输过程中保存消息的容器。
>
> 消息队列中间件是分布式系统中重要的组件，主要解决应用耦合，异步消息，流量削锋等问题实现高性能，高可用，可伸缩和最终一致性架构

##### 消息队列应用场景

1. 异步处理：例如短信通知、终端状态推送、App推送、用户注册等
2. 数据同步：业务数据推送同步
3. 重试补偿：记账失败重试
4. 系统解耦：通讯上下行、终端异常监控、分布式事件中心
5. 流量消峰：秒杀场景下的下单处理
6. 发布订阅：HSF的服务状态变化通知、分布式事件中心
7. 高并发缓冲：日志服务、监控上报

##### 特点

1. 消息的同步和异步收发
   1. 同步：同步收发场景下，消息生产者和消费者双向应答模式，例如：张三写封信送到邮局中转站，然后李四从中转站获得信，然后在写一份回执信，放到中转站，然后张三去取，当然张三写信的时候就得写明回信地址
   2. 异步：异步发送消息，不需要等待消息队列的接收确认；异步接收消息，以Push的方式触发消息消费者接收消息。


1. ##### 消息队列两种模式

   1. 点对点
   2. 发布订阅模式
   3. 详细https://blog.csdn.net/cws1214/article/details/52922267



### Debug和Release区别？

##### Debug  通常称为调试版本

​	它包含调试信息，并且不作任何优化，便于程序员调试程序。

1. 在bin\debug\目录中有两个文件，除了要生成的.exe或.dll文件外，还有.pdb文件，
2. .pdb文件中就记录了代码中的断点等调试信息；

##### Release 称为发布版本

​	Release模式下不包含调试信息，并对代码进行了优化，使得程序在代码大小和运行速度上都是最优的

1. \bin\release\目录下只有一个.exe或.dll文件。还有个obj目录
2. 编译是分模块编译的，每个模块的编译结果就保存在了obj目录下,最后会合并为一个exe或者dll文件保存到\bin\release\目录中

##### 总结

​	需要调试程序时，选用Debug选项 需要程序快速运行时，选用Release选项

​	

### 序列化反序列化

> #####序列化：将数据结构转换称为二进制数据流或者文本流的过程，方便在网络上和磁盘存储
>
> 反序列化：是将二进制数据流或者文本流转换称为易于处理和阅读的数据结构的过程。

##### 为什么需要序列化？

1. 不同环境不同平台字节表示不同，数据所表示的含义也不同，所以需要将格式转换成大家都认识的格式，也就是二进制，那么这个数据可以在任何环境平台保存，这就是序列化的意义；

##### **使用C++将对象进行序列化的几种方法**

1. 基于Boost库的方法；

   1. Boost中，与序列化有关的两个库是Archive库和<u>Serialization</u>库。

   2. 实现步骤

      首先，为被序列化的类实现一个对应的serialize(Archive & ar, const unsigned int version)方法；

      其次，构造boost::archive::text_oarchive类或其他archive输出类的对象，并将其关联到一个输出流，利用<<运算符将被序列化的对象输出到某个文档中；

      最后，构造boost::archive::text_iarchive类或其他archive输入类的对象，并将其关联到一个输入流，读入数据，利用>>运算符会付出被序列化的对象。

2. 基于.Net Framework的方法；

3. 以及基于MFC的方法。

+ **侵入式和非侵入式**
+ **派生类的序列化**
+ **数组的序列化**
+ **指针的序列化**

> 原链接：https://blog.csdn.net/wangwangfish/article/details/8112974

### 编码解码

> 其约定的是更底层一些的数据含义，例如字符的表示，有ASCII、UTF-8、GBK等等



### 二进制流和文本流区别

> 二进制流：二进制流是以二进制为最小单位进行编码，例如多少个bit代表什么，
>
> 文本流 ：是以字符来进行编码，约定好多少个字节（通常是以字节为单位）代表什么。



### 大端小端

> #####大端（BigEndian）：低字节在高内存地址 
>
> ##### 小端（LittleEndian）：低字节在低内存地址
>
> 定义：是指字节存储或传输时的顺序。

##### 为什么会有大小端模式之分呢？



##### 如何判断机器的字节序？

~~~c++
BOOL IsBigEndian()  
{  
    int a = 0x1234;  
    char b =  *(char *)&a;  //通过将int强制类型转换成char单字节，通过判断起始存储位置。即等于 取b等于a的低地址部分  
    if( b == 0x12)  
    {  
        return TRUE;  
    }  
    return FALSE;  
}
~~~

~~~c++
BOOL IsBigEndian()  
{  
    union NUM  
    {  
        int a;  
        char b;  
    }num;  
    num.a = 0x1234;  
    if( num.b == 0x12 )  
    {  
        return TRUE;  
    }  
    return FALSE;  
}
~~~

##### 如何进行转换

 ~~~c++
#define ntohs(n)     //16位数据类型网络字节顺序到主机字节顺序的转换  
#define htons(n)     //16位数据类型主机字节顺序到网络字节顺序的转换  
#define ntohl(n)      //32位数据类型网络字节顺序到主机字节顺序的转换  
#define htonl(n)      //32位数据类型主机字节顺序到网络字节顺序的转换  
在大端模式的处理器下对文件的32，16位读写操作所得到的结果与小端模式的处理器不同。单纯从软件的角度理解上远远不能真正理解大小端模式的区别。事实上，真正的理解大小端模式的区别，必须要从系统的角度，从指令集，寄存器和数据总线上深入理解，大小端模式的区别。
 ~~~

注意点：tcp协议采用大端字节序，Mac OS是大端模式，OS（如windows，FreeBSD,Linux）使用的是小端模式 , 一般操作系统都是小端，而通讯协议是大端的。

### 指针偏移 



### 回调函数

> ### 

### 递归 

> ### 

### 心跳包

### namespace 命名空间

> 实际上就是一个由程序设计者命名的内存区域，程序设计者可以根据需要指定一些有名字的空间域，把一些全局实体分别放在各个命名空间中，从而与其他全局实体分隔开来。

##### 为什么要用命名空间？

​	C++引入的可以由用户命名的作用域，用来处理程序中 常见的同名冲突。

##### 无名的命名空间



### handle 句柄

> 操作系统内核看得懂的无符号整数(unsigned int)都可以被看作是handle
>
> 句柄是用来标识一个对象或者项目的，16位无符号整数，使用该句柄，以引用相应的对象
>
> 进程号pid就是一个handle,
>
> 文件描述符(fd)也是一个handle,  对用户来说只看结果，不看过程，使用秘钥操作黑盒子一样
>
> windows为每个应用程序建立一张表，实例句柄就好像是这张表的一个索引
>
> windows不仅使用句柄来管理实例，也用它来管理窗口，位图，字体，元文件，图标等系统资源
>
> 在windows环境中，句柄是用来标识项目的，这些项目包括：模块，任务，实例

 

### boost库之智能指针之共享指针

> <u>shared_ptr 管理动态创建的对象的销毁</u>,它的基本原理就是记录对象被引用的次数，当引用次数为 0 的时候，也就是最后一个指向某对象的共享指针析构的时候，共享指针的析构函数就把指向的内存区域释放掉。
>
>  智能指针实质就是重载了->和*操作符的类，由类来实现对内存的管理，确保即使有异常产生，也可以通过智能指针类的析构函数完成内存的释放。

1. ```
   头文件：#include <boost/shared_ptr.hpp> 
   ```

2.  使用shared_ptr避免了手动使用delete来释放由new申请的资源

3. C++开发处理内存泄漏最有效的办法就是使用智能指针，使用智能指针就不会担心内存泄露的问题了，因为智能指针可以自动删除分配的内存。

4. https://blog.csdn.net/fengbingchun/article/details/52202007





### boost库之tcp 异步服务器



### libevent库之evhttp (libevent 实现http服务器)

> #####  https://blog.csdn.net/luotuo44/article/details/38800363



### 多线程tcp udp服务器模型





### localhost与127.0.0.1与本机IP

> **localhost** 是个域名，本地DNS解析127.0.0.1 域名，可以随便改本地路径：c:\win\system32\driver\etc

> "**127.0.0.1**" 回送地址，一般用测试本机tcp/ip,本机进程间通讯，使用该发送协议

> **本机IP** ： 指连接到计算机上的ip地址，内网 公网IP

|      | localhost              | 127.0.0.1                |          本机IP          |
| ---- | :--------------------- | :----------------------- | :----------------------: |
| 网络 | 不联网                 | 不联网                   |           联机           |
| 传输 | 不使网卡，不受防火墙限 | 网卡传输，受网卡防火墙限 | 网卡传输，受网卡防火墙限 |
| 访问 | 本机访问               | 本机访问                 |      本机或外部访问      |

### 网络基础知识点

##### 字节序

##### 帧，帧头

##### 指令码

##### 数据域

##### 网卡

> 网卡是工作在链路层的网络组件，是局域网中连接计算机和传输介质的接口，不仅能实现与局域网传输介质之间的物理连接和电信号匹配，还涉及帧的发送与接收、帧的封装与拆封、介质访问控制、数据的编码与解码以及数据缓存的功能等。

### tftp传输协议（实现传输服务器）

> tftp 简单文件传输协议：是TCP/IP协议族中的一个用来在客户机与[服务器](https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8)之间进行简单文件传输的协议，提供不复杂、开销不大的[文件传输服务](https://baike.baidu.com/item/%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E6%9C%8D%E5%8A%A1/5389842)。[端口号](https://baike.baidu.com/item/%E7%AB%AF%E5%8F%A3%E5%8F%B7/10883658)为69。

### tftp工具

### Wireshark抓包工具

### UWB 

### source Insignt4.0 添加文件类型

![1535600212528](C:\Users\ASUS-PC\Desktop\个人文档\assets\1535600212528.png)

![1535600235847](C:\Users\ASUS-PC\Desktop\个人文档\assets\1535600235847.png)

### epoll 反应堆

### 粘包

##### 定义

TCP粘包是指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。

##### 为什么tcp粘包？

> <u>说白了就是tcp 的优化算法，为了提供效率将多个小包合成一包再一次发送出去，故此接收端就出现了粘包问题</u>
>
> （发送端为了将多个发往接收端的包，更有效的发到对方，使用了优化方法（Nagle算法），将多次间隔较小、数据量小的数据，合并成一个大的数据块，然后进行封包 ）

##### 长连接

>  Client方与Server方先建立通讯连接，连接建立后 不断开， 然后再进行报文发送和接收。

##### 短连接

> Client方与Server每进行一次报文收发交易时才进行通讯连接，交易完毕后立即断开连接。此种方式常用于一点对多点通讯，比如多个Client连接一个Server.

##### 特点

> tcp:面向流传输 
>
> udp 不会出现粘包问题 
>
> ​	答：udp基于数据报文协议两端数据是有界限的，要接受发送完整要么不接收。

##### 什么时候考虑粘包问题

> 发送不同的数据结构时，需要考虑
>
> 短连接发送数据和文件传输（对方只需要接收就行）所以该情况不需要考虑粘包问题

##### 粘包问题产生

1. 发送端等待缓冲区满了才将数据发送出去
2. 接收端等缓冲区满接收，没有及时接收缓冲区，造成多个包堆在一起

##### 避免粘包措施

> 1. 发送端收到数据立即传出去，不写入缓冲区 ，缺点：降低程序性能
> 2. 接收端及时接收数据，提高接收的优先级，可以减少粘包次数，但是高峰期还是会粘包
> 3. 接收方控制，接受的数据分批次存到结构体中，然后再合并，避免粘包， 缺点：避免了粘包但是不实用
> 4. 一种比较周全的对策是：<u>接收方创建一预处理线程，对接收到的数据包进行预处理，将粘连的包分开。</u>
>    1. 具体可以参考：<http://blog.csdn.net/soli/article/details/1297109>

##### 粘包的情况

1. 粘的完整的数据包
2. 粘在一起的不是完整的数据包

##### tcp 无消息边界   （就像流水一样）

>发送固定长度消息
>
>消息和尺寸一起发送
>
>特殊标记来区分消息间隔

##### 为什么tcp 通讯要拆包解包

> TCP是个"流"协议，所谓流，就是没有界限的一串数据，大家可以想想河里的流水，是连成一片的，其间是没有分界线的。

封包

> 该包加上包头，加上包体，包头结构体存储包长度等信息，只要更具包头长度就能拆分出一个完整的数据包

拆包（解包）







### 面向对象相关知识点

##### 成员类

##### 多态

##### 虚函数，纯虚函数

##### 运算符重载

##### 拷贝构造

CExample(const CExample& C)　就是我们自定义的拷贝构造函数。可见，拷贝构造函数是一种特殊的构造函数，函数的名称必须和类名称一致，它必须的一个参数是本类型的一个引用变量。

拷贝函数调用的时机

对象以值传递的方式传入函数参数

对象以值传递的方式从函数返回

对象需要通过另外一个对象进行初始化；

```
CExample A(100);   
CExample B = A;   
```

#### 内部类

##### 代码

```c++
内部类内声明类外实现案例：
class server { 
public:
	void outi() {
		printf("songchao");
	};
	class server_in; 
}; 
class server::server_in { 
	public:
		static void outi() {
			printf("songchao  in");
		};  
};  
int main() { 
	server::server_in::outi(); 
	system("pause");
	return 0;
}
```

##### 定义

​	一个类定义在另一个类的内部，这个内部类就叫做内部类

##### 特点

1. 不能通过外部类的对象去调用内部类。<u>外部类对内部类没有任何优越的访问权限。</u>

2. ##### 内部类可以定义在外部类的public、protected、private都是可以的。

3. ##### 注意内部类可以直接访问外部类中的static、枚举成员，不需要外部类的对象/类名。

4. ##### <u>内部类可以现在外部类中声明，然后在外部类外定义</u>

5. ##### 嵌 套 类 也 可以 被 声明 为 静 态 或 者非 静 态的 。 静态 嵌 套 类


1. ##### 为什么定义使用内部类？

##### 作用

1. 在大型项目中环境和包往往占很大空间，而且该项目还要提供给用户端使用，还需要配置所需环境

2. 使用内部类将环境全部声明内部类中，让后进行编译，生成库之后外部类调用就好了，环境已经打包好dll适用方只需要调用，不需要管环境，而且开发人员也不需要对象源码进行接口隐藏，全在内部类中了

   ##### 总结一下：

   其实内部类和友元类很像很像。只是内部类比友元类多了一点权限：可以不加类名的访问外部类中的static、枚举成员。其他的都和友元类一样。



#### friend 友元类

##### 	定义：

​	允许一个类的非公有成员被一个类或者函数访问。

##### 	分类：

​	普通非成员函数做友元

​	类成员函数做友元

> 在声明友元的时候要用类限定符，所以必须先定义包含友元函数的类，但是在定义友元的函数时候，又必须事先定义原始类。通常的做法先定义包含友元函数的类，再定义原始类，这个顺序不能乱。(

​	类做友元

> 类作为友元需要注意的是友元类和原始类之间的相互依赖关系，如果在友元类中定义的函数使用到了原始类的私有变量，那么就需要在友元类定义的文件中包含原始类定义的头文件。
>
> (但是在原始类的定义中（包含友元类声明的那个类），就不需要包含友元类的头文件，也不需要在类定义前去声明友元类，因为友元类的声明自身就是一种声明（它指明可以在类外找到友元类）)

##### 	特点：

​	友元不能被继承

​	友元不具有传递性

​	如果想要指定两个类都有成员函数作为对方的友元，那么必须第2个类是第一个类的友元

​	如果想要指定两个类都有成员函数作为对方的友元，那么必须第2个类是第一个类的友元





### qt  http 类实现客户端请求接受





### hpp  

将.cpp的实现代码混入.h头文件当中,定义与实现都包含在同一文件

(则该类的调用者只需要include该cpp文件即可，无需再 将cpp加入到project中进行编译。而实现代码将直接编译到调用者的obj文件中，不再生成单独的obj,采用hpp将大幅度减少调用 project中的cpp文件数与编译次数，也不用再发布烦人的lib与dll,因此非常适合用来编写公用的开源库。)

> 1.  最表面的机制是：头文件是程序的界面（是代码界面），提供给程序员以  类、模版、函数等一系列的声明，让程序员知道应该怎么调用里面的“东西”。
>
> 2. 从动态链接库的角度看：头文件提供界面，使得程序员在需要加载一个库函数的时候（这里也仅仅是举简单的例子）查看头文件就知道怎么加载这个动态库内部的函数。
>
> 3. 从软件的扩展来说：将头文件作为界面，再去定义它的实现，这样只要保证界面不变（头文件不变），就可以只修改实现文件，而不必修改其他的实现代码。比如你有一个sort()函数来排序，在一个大程序中，你后来发现这个sort()有更好的算法，于是你只需要去修改函数的实现（修改.cpp文件的sort（）函数的代码），其他使用这个函数的地方可以完全保持不变，这是分割技术的第一个好处
>
> 4. 从编译的角度看：
>
>    所有源文件都是被编译器分别划分单元来分别编译，在编译的过程中，头文件被嵌入到实现文件里面一起作为一个编译单元被编译（实现文件filename.cpp里的#include "filename.h"这一行被替换成filename.h里面的所有内容（实际上会把预处理指令去掉，这才是预处理最本质的作用））。
>
>    举一个简单的例子，你定义了sort（）函数，在test.h头文件里声明，在test.cpp里定义，这个时候在test.cpp里面#include "test.h"，并定义sort（）函数。
>
>    你需要在头文件内部写预处理代码

### qt close clear

### 串行接口

指数据一位一位地顺序传送，其特点是[通信线路](https://baike.baidu.com/item/%E9%80%9A%E4%BF%A1%E7%BA%BF%E8%B7%AF/1527630)简单，只要一对传输线就可以实现双向通信（可以直接利用电话线作为传输线），从而大大降低了成本，特别适用于远距离通信，但传送速度较慢。



### QElapsedTimer

> 提供了一种快捷的计算流逝时间的方法。它通常被用来计算两个事件或操作之间过去了多久。

### QApplication::processEvents

> 在处理一些与界面无关程序时，耗费资源导致界面假死，无响应，例如：写程序保存磁盘文件中,如果不想使用多线程，最简单的办法就是在文件保存过程中**频繁调用QApplication::processEvents()**该函数的作用是让程序处理那些还没有处理的事件，然后再把使用权返回给调用者。



该方法有一个问题：可能正在保存文件的过程中，用户不小心又单击了保存，或不小心关闭了程序主窗口，这样会产生意想不到的后果。

> ```
> qApp->processEvents(QEventLoop::ExcludeUserInputEvents);//它可以忽略用户的输入（鼠标和键盘事件）。
> ```



> 另一种方法就是多线程写入磁盘，主线程处理界面

> https://blog.csdn.net/u011430225/article/details/68926464



#### qt QElapsedTimer的毫秒数

```
  m_tim.start(); 
  while(m_tim.elapsed() < 3000) // m_tim.elapsed() 放回上次启动的 QElapsedTimer的毫秒数
```

 

qt 不同对象发送的同名信号槽函数如何区分



###if、#elif、#else 和 #endif 条件编译 

> if 指令与 #elif、#else 和 #endif 指令一起控制源文件部分的编译。 如果您编写的表达式（在 #if 后）有一个非零值，则在翻译单元中保留紧跟 #if 指令的行组。

注意：

> + 源文件中的每个 #if 指令必须与表示结束的 #endif 指令匹配
>
> + 任意数量的 #elif 指令可以出现在 #if 和 #endif 指令之间
>
> + if、#elif、#else 和 #endif 指令可以嵌套在其他 #if 指令的文本部分中
>
> + ~~~shell
>   defined( identifier )
>   defined identifier
>   如果当前定义了 identifier，则该常量表达式被视为 true（非零）；否则条件为 false (0)。 定义为空文本的标识符被视为已定义。 defined 指令可用于 #if 和 #elif 指令，但在其他位置不可用。
>   ~~~
>
> + ```
>   #if defined(CREDIT)   
>       credit();   
>   #elif defined(DEBIT) 
>       debit();    
>   #else   
>       printerror();    
>   #endif  
>   标识符 CREDIT，则编译对 credit 的函数调用。 如果定义了标识符 DEBIT，则编译对 debit 的函数调用
>   ```



> + ~~~shell
>   #if !defined( EXAMPLE_H )  
>   #define EXAMPLE_H  
>     
>   class Example  
>   {  
>   ...  
>   };   
>   #endif
>   面的代码将检查以查看是否定义了符号常量 EXAMPLE_H。 如果是这样，则已包括该文件，并且不需要重新处理该文件。 否则，定义常量 EXAMPLE_H 以将 EXAMPLE.H 标记为已处理 
>   ~~~
>
> + ~~~shell
>       #if DLEVEL > 5  
>           #define SIGNAL  1  
>           #if STACKUSE == 1  
>               #define STACK   200  
>           #else  
>               #define STACK   100  
>           #endif  
>       #else  
>           #define SIGNAL  0  
>           #if STACKUSE == 1  
>               #define STACK   100  
>           #else  
>               #define STACK   50  
>           #endif  
>       #endif  
>       #if DLEVEL == 0  
>           #define STACK 0  
>       #elif DLEVEL == 1  
>           #define STACK 100  
>       #elif DLEVEL > 5  
>           display( debugptr );  
>       #else  
>           #define STACK 200  
>       #endif  
>   ~~~
>
> + ​



### 宏知识点 

> 编译器对宏的处理是在预编译阶段进行的,简单替换，编译器并不会对宏本身和宏参数进行任何类型 语法检查，不易阅读和调试

##### 宏分类

+ 宏对象  没有参数的宏。这类宏常常被用来定义常量  #define xxx 10
+ 宏函数 带有参数的宏。这类宏的应用场景很多，比如定义函数、产生代码等等，随着用法的不同，难易程度也有很大的波动 例如：#define MAX(a,b)  ((a)>(b)  > (a)  : (b) )   

##### 宏操作符

+ ‘#’  字符串话一个宏 加上’#‘就好 #define STRINGIZE(arg) #arg

+ '#'@：字符化一个宏参数，即在参数名字前后加上'。例如：

  ```
  #define CHARIZE(arg) #@arg
  ```

+ 拼接宏参数和另一个符号，即连接两个符号生成一个新的符号。#define SYMBOL_CATENATE(arg1, arg2) arg1 ## arg2

+ \：换行，即开始新的一行继续定义宏体。例如：

  ```
  #define DEFINE_VARIABLE(name1, name2, type) type name1; \ 
  	type name2;
  ```

##### 变参宏

~~~shell
宏函数也可以接受个数不定的参数，形参写为...，在宏体内获取形参使用__VA_ARGS__，例如：

#define PRINTF(format, ...) printf(format, __VA_ARGS__);

注意：当__VA_ARGS__作为宏实参再次被传入另一个宏函数的时候，在VC下直接编译时__VA_ARGS__只会被解释为一个参数，例如下面代码： 
~~~

##### 内置宏

~~~shell
c/c++标准中预定义了几个宏，只要编译器是支持标准的即可以在代码中直接使用这些宏：

__LINE__ // 当前代码行的行号
__FILE__ // 源程序的完整路径
__DATE__ // 系统日期
__TIME__ // 系统时间
__TIMESTAMP__   // 系统时间戳
__FUNCTION__ // 当前代码行所在的函数的名字
__STDC__ // 当要求程序严格遵循ANSI C标准时该标识被赋值为1
__cplusplus // 当编写C++程序时该标识符被定义
~~~

##### 宏技巧

​	1.遍历变参宏的每个参数

​	2.<u>跨平台程序开发</u>

​	一些编译器提供的平台相关的预定义宏，可以很方便的用来做跨平台开发，例如：

~~~shell
#if defined(WIN32) || defined(_WIN32) || defined(__WIN32__) || defined(__NT__)
 
// windows
 
#elif defined(__linux__) || defined(__linux)
 
// linux 
#endif
~~~



​	3.利用预定义宏调试程序

​		__FILE__、__LINE__、__FUNCTION__等可以很方便的获取程序相关的信息，当程序出现错误时，利用这些宏可以及时地生成错误信息并输出到日志中，以便查看和调试。

​	4.调试宏定义

​		4.1查看宏展开后的完整代码

​			VC下可以利用"生成预处理文件"选项，<u>宏展开后的代码将输出到.i文件中</u>，操作参考：[点击打开链接](http://blog.csdn.net/qyee16/article/details/9322281)

GCC下使用编译选项-E即可。

​	5.宏元编程



### __declspec(dllexport)与__declspec(dllimport)

> 定义： 他们都是DLL内的关键字，即导出与导入。他们是将DLL内部的类与函数以及数据导出与导入时使用的。

>  <u>dllexport</u>是在这些类、函数以及数据的申明的时候使用(用他表明这些东西可以被外部函数使用，即（dllexport）是把 DLL中的相关代码（类，函数，数据）暴露出来为其他应用程序使用。)

>   <u>dllimport</u>是在外部程序需要使用DLL内相关内容时使用的关键字。当一个外部程序要使用DLL 内部代码（类，函数，全局变量）时，只需要在程序内部使用（dllimport）关键字声明需要使用的代码就可以了，即（dllimport）关键字是在外部程序需要使用DLL内部相关内容的时候才使用

##### 用法：

~~~shell
#ifdef DLL_EXPORTS 
      #define SIMPLE_CLASS_EXPORT __declspec(dllexport) 
#else 
       #define SIMPLE_CLASS_EXPORT __declspec(dllimport) 
#endif
~~~

##### **动态库与静态库并存**

##### __使用declspec(dllexport)与__declspec(dllimport)和不用区别

> MSDN文档里面，对于__declspec(dllimport)的说明

> 不使用 __declspec(dllimport) 也能正确编译代码，但使用 __declspec(dllimport) 使编译器可以生成更好的代码。编译器之所以能够生成更好的代码，是因为它可以确定函数是否存在于 DLL 中，这使得编译器可以生成跳过间接寻址级别的代码，而这些代码通常会出现在跨 DLL 边界的函数调用中。但是，必须使用 __declspec(dllimport) 才能导入 DLL 中使用的变量。

```
__declspec(dllexport)：可以使用dll中的函数,但是不能使用dll中的静态变量。
__declspec(dllimport)：可以使用dll中的函数和静态变量。
```

~~~shell
地址：https://blog.csdn.net/henryrao1221/article/details/24421825
代码案例： F:\newProject\SimpleClass_dll
		 F:\newProject\SimpleClass_dll_test
~~~

### window 导入导出

目的就是将自己写好的代码，提供给客户去用，但是不能让拥有源码。

### 宏 系统关键字

ifndef _DLL_H_

define _DLL_H_//防重复定义

ifndef __HDTAS_HEADER_H__  // 防止重复编译

define __HDTAS_HEADER_H__

​	<https://blog.csdn.net/u014403008/article/details/62858230>



### 动态库静态库		

被人是怎么用我的动态库，我项目是如何打包库

> 打包和使用动态库https://blog.csdn.net/m0_37170593/article/details/76445972



### c++ 内存释放问题

> 我总是忘记和不知道到底在哪里正确的释放内存，一脸闷逼真的，是在是不知道在哪里释放内存，还有那个只能指针的使用，  这个东西难道不是靠写出来的吗，是靠看文档看出来的吗？ 宋超?	



### 看代码技巧

1. 首先看头文件（面向对象语言看类定义宏）了解基本结构:看项目结构
2. 看流程（能够编译调试最好一步一步走）开始点到结束；
3. 看具体的解决方案（用什么技术解决的，怎么解决的问题）例如：怎么解决序列化？
4. 解决项目中简单的bug或者单独模仿某个功能或模块，或直接做项目扩展





### qt 使用动态库文件



### github 使用

### git命令 

### gitlab 使用

### log 日志使用配置



### QT之界面与业务逻辑的分离

~~~shell
http://blog.51cto.com/12810168/2091380
~~~

